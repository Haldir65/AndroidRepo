两件事：
- 1. 确保这个so文件只能被当前的apk调用
- 2. 在c,c++层面使用AES对称加密字符串返回给java层



[在so文件中存储通信秘钥，并实现App签名验证避免二次打包](http://wxmylife.com/2017/03/22/Android%E9%80%9A%E8%BF%87JNI%E5%8A%A0%E5%AF%86%EF%BC%8C%E5%B9%B6%E5%AE%9E%E7%8E%B0APP%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/)
上面的只是在so文件中返回了一个string，每次java调用native方法返回的都会是同一个字符串，如何实现调用jni方法对一个字符串进行加密？

服务器下发一个userId(String)，并期待客户端下次请求的时候带上一个参数，这个参数应该是对刚才这个userId的加密结果，而这个加密结果只有客户端才能生成。

加密的过程采用对称加密，客户端在c层面保留一个secretKey（后台也知道这个secretKey），客户端使用任意的不可逆加密算法生成这个结果。这些都是在so文件中实现的。
后台也使用这个secretKey和相同的加密算法生成这个加密后的结果。客户端请求到达后，判断下传来的字符串是否符合预期。不符合的话，直接返回invalid client消息

客户端加密没有必要多次，可以加密之后将加密结果存储在本地文件系统中。

[AES加密实例](https://my.oschina.net/u/2963604/blog/1612903)